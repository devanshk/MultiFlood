"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePackages = exports.processPromise = void 0;
const colorette_1 = require("colorette");
const logger_1 = __importDefault(require("webpack-cli/lib/utils/logger"));
const path_1 = __importDefault(require("path"));
const modify_config_helper_1 = require("./modify-config-helper");
const global_packages_path_1 = require("./global-packages-path");
const spawn_child_1 = require("./spawn-child");
const path_utils_1 = require("./path-utils");
/**
 *
 * Attaches a promise to the installation of the package
 *
 * @param {Function} child - The function to attach a promise to
 * @returns {Promise} promise - Returns a promise to the installation
 */
function processPromise(child) {
    return new Promise((resolve, reject) => {
        if (child.exitCode !== 0) {
            reject();
        }
        else {
            resolve();
        }
    });
}
exports.processPromise = processPromise;
/**
 *
 * Resolves and installs the packages, later sending them to @creator
 *
 * @param {String[]} pkg - The dependencies to be installed
 * @returns {Function|Error} creator - Builds
 * a webpack configuration through yeoman or throws an error
 */
function resolvePackages(pkg) {
    Error.stackTraceLimit = 30;
    const packageLocations = [];
    function invokeGeneratorIfReady() {
        if (packageLocations.length === pkg.length) {
            modify_config_helper_1.modifyHelperUtil('init', null, null, packageLocations);
        }
    }
    pkg.forEach((scaffold) => {
        // Resolve paths to modules on local filesystem
        if (path_utils_1.isLocalPath(scaffold)) {
            let absolutePath = scaffold;
            try {
                absolutePath = path_1.default.resolve(process.cwd(), scaffold);
                require.resolve(absolutePath);
                packageLocations.push(absolutePath);
            }
            catch (err) {
                logger_1.default.error(`Cannot find a generator at ${absolutePath}.\n`);
                logger_1.default.error('Reason:\n');
                logger_1.default.error(colorette_1.bold(err));
                process.exitCode = 1;
            }
            invokeGeneratorIfReady();
            return;
        }
        // Resolve modules on npm registry
        processPromise(spawn_child_1.spawnChild(scaffold))
            .then(() => {
            try {
                const globalPath = global_packages_path_1.getPathToGlobalPackages();
                packageLocations.push(path_1.default.resolve(globalPath, scaffold));
            }
            catch (err) {
                logger_1.default.error("Package wasn't validated correctly...");
                logger_1.default.error(`Submit an issue for ${pkg} if this persists\n`);
                logger_1.default.error('Reason:\n');
                logger_1.default.error(colorette_1.bold(err));
                process.exitCode = 1;
            }
        })
            .catch((err) => {
            logger_1.default.error("Package couldn't be installed, aborting...\n");
            logger_1.default.error('Reason:\n');
            logger_1.default.error(colorette_1.bold(err));
            process.exitCode = 1;
        })
            .then(invokeGeneratorIfReady);
    });
}
exports.resolvePackages = resolvePackages;
